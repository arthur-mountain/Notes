# AI Agent 的設計: 從基礎型到完整型

## 基礎型 AI Agent

### 具備感知能力

- 從用戶端接收輸入(例如文本輸入或命令)。

### 具備決策能力

- 後端會通過調用現成的 LLM(如 GPT)來理解和回應用戶需求，實現邏輯推理。

### 具備行動能力

- 將生成的結果返回到前端，完成任務閉環。

但這樣的設計主要依賴於外部 LLM，且功能通常集中於處理單一任務或回答問題，還不算複雜的智能代理。

## 「基礎型 AI Agent」與「完整的 AI Agent」有何不同？

更高階的 AI Agent 往往具有以下特徵，而不只是單純的前後端串接：

### 1. 自主性與多任務處理

- 更高階的 AI Agent 能在多任務場景中自主決策和切換，而不需要每次都依賴用戶提供指令。

- 例如，它能根據用戶的歷史行為預測需求，或同時管理多個上下文(像 ChatGPT 能處理多輪對話)。

### 2. 記憶與上下文管理

- `單純的 LLM 調用是無狀態的，它對過往對話沒有記憶`。

- `完整的 AI Agent 需要設計「記憶層」，用於保存上下文或用戶偏好`。

#### 實現方式

- **數據庫(例如 Redis)** 來存儲會話歷史。

- **使用框架(如 LangChain)** 來擴展 LLM 的記憶功能。

### 3. 自主執行外部行動

高階 AI Agent 能與其他系統或硬體進行交互，完成更複雜的任務，例如：

- 調用 **日曆 API** 自動安排會議。

- 操控 **IoT 設備** 執行實體世界的指令。

- **自主檢索網路信息** 以補充回答。

### 4. 擴展知識庫

- 單純使用現成的 LLM，知識範圍局限於訓練數據的截止日期。

- 完整 AI Agent 可自動接入外部知識庫(如公司內部資料、文件檔案)，並對其進行增量學習或檢索。

## 如何進一步提升成為真正的 AI Agent？

如果你想要超越基礎設計，可以逐步添加以下功能：

### 1. 上下文記憶

- 在後端添加記憶功能，保存用戶的會話歷史或偏好。

#### 使用工具

- **Redis**：作為快取數據存儲。

- **LangChain**：與 LLM 結合，提供記憶功能。

### 2. 多任務處理

- 利用 **多執行緒或事件驅動框架**(如 Node.js eventloop、Java Multi-threads、Golang goroutines)支持同時處理多個請求。

- 引入 **任務隊列**(如 RabbitMQ、Kafka、AWS SQS)管理異步任務。

### 3. 接入更多外部資源

- 增加其他 **API 或服務**(如地圖、支付、日曆等)的調用能力。

- 讓 Agent **不僅能回答問題，還能執行具體操作**。

### 4. 加強部署架構

考慮使用 **微服務架構** 將功能模組化，例如：

- **一個模組** 處理語音輸入。

- **一個模組** 處理文件檢索。

- **一個模組** 專注於 LLM 回應。

### 5. 自主學習與模型微調

- 將 **用戶反饋(Feedback Loop)** 納入設計，讓系統不斷改進。

- 利用 **自己的數據集** 對現有模型進行微調，使之更加專注於特定領域。

## 結論

設計一個基礎型的 AI Agent，適合快速構建和展示原型。

隨著需求增加，你可以通過增加 **記憶、上下文處理、多任務支持、自主行動** 等功能，逐步將它擴展為 **一個更高階、更智能的 AI Agent**。

模組化的部分，因為每個 agent 負責一件事，如果有更大的需求的話，背後可能有多個 agent(multi agents) 在處理

這樣的系統就不僅僅是「串接 LLM」，而是一個真正的 **智能代理**。
