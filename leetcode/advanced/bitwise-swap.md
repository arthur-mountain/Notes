# Bitwise Swap(位元運算交換

使用 **XOR(異或運算)** 和 **Mask(遮罩位操作)** 進行交換的原理，建立在 XOR 運算的數學特性之上:

## **XOR 的特性**

XOR(^)具有以下幾個關鍵特性:

1. **交換律**: `a ^ b = b ^ a`

2. **結合律**: `a ^ (b ^ c) = (a ^ b) ^ c`

3. **自反性**: `a ^ a = 0`

4. **恆等性**: `a ^ 0 = a`

基於這些特性，異或運算可以巧妙地實現變數交換，且不需要額外的存儲空間。

## **XOR 實現交換的原理**

假設有兩個變數 `a` 和 `b`:

1. `a = a ^ b`:

   此時，`a` 儲存了 `a` 和 `b` 的異或結果。

2. `b = a ^ b`:

   此時，由於 `a` 是 `a ^ b`，所以 `b` 被重新賦值為 `a ^ b ^ b`。

   根據自反性 `b ^ b = 0`，所以 `b = a`。

3. `a = a ^ b`:

   此時，由於 `b` 已經是原來的 `a`，所以 `a = a ^ b ^ a`。

   根據自反性 `a ^ a = 0`，所以 `a = b`。

最終結果是 `a` 和 `b` 互換，且不需要額外的存儲空間。

### **範例程式碼**

```c
int a = 5; // 二進位: 0101
int b = 3; // 二進位: 0011

a = a ^ b; // a = 0101 ^ 0011 = 0110
b = a ^ b; // b = 0110 ^ 0011 = 0101 (原本的 a)
a = a ^ b; // a = 0110 ^ 0101 = 0011 (原本的 b)

// 最終: a = 3, b = 5
```

## **Mask(遮罩)的原理**

遮罩方法是 XOR 的一種變形，用來操作特定位元(位元遮罩技術)。

其原理是基於 XOR 生成“差異標記”來進行交換。

假設我們有 `a` 和 `b`，希望用 XOR 和遮罩進行交換:

1. 計算一個差異遮罩: `mask = a ^ b`。

   此時，`mask` 表示 `a` 和 `b` 在位元層級上的不同點。

2. 使用 `mask` 修改 `a`: `a = a ^ mask`，此時 `a` 的值被更新為 `b`。

3. 使用相同的 `mask` 修改 `b`: `b = b ^ mask`，此時 `b` 的值被更新為 `a`。

**遮罩的核心思想**是通過“差異”儲存在 `mask` 中，然後利用這一差異去還原原始值。

### **遮罩法的範例程式碼**

```c
int a = 5; // 二進位: 0101
int b = 3; // 二進位: 0011

int mask = a ^ b; // mask = 0101 ^ 0011 = 0110

a = a ^ mask; // a = 0101 ^ 0110 = 0011 (原本的 b)
b = b ^ mask; // b = 0011 ^ 0110 = 0101 (原本的 a)

// 最終: a = 3, b = 5
```

## **為什麼可以交換？**

XOR 交換或遮罩操作的核心在於 **資訊未丟失**。

- 在第一步(`a = a ^ b` 或 `mask = a ^ b`)中，新的值同時包含了 `a` 和 `b` 的資訊。

- 後續運算(基於 XOR 的逆運算性質)能夠從組合資訊中提取出原始值。

由於 XOR 運算滿足上述數學特性，整個過程可以保證不需要額外的存儲空間，且能夠成功交換兩個值。
