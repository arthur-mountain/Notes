### 1. 位運算（Bitwise Operation）

位運算是直接在數字的二進制表示上操作的數學運算。

常見的位運算包括 **AND** (`&`)、**OR** (`|`)、**XOR** (`^`)、**NOT** (`~`)、**左移** (`<<`) 和 **右移** (`>>`)。

這些運算會直接作用於數字的每一個二進制位。

#### 例子

有兩個數字，它們的二進制表示如下：

```plain
5 = 0101  (二進制)
3 = 0011  (二進制)
```

**位 AND (`&`) 運算**：

```plain
5 & 3 = 0101 & 0011 = 0001 (結果是 1)
```

- 只有當兩個位置的數字都為 1 時，結果才是 1，否則結果是 0。

**位 OR (`|`) 運算**：

```plain
5 | 3 = 0101 | 0011 = 0111 (結果是 7)
```

- 只要其中一個位置的數字是 1，結果就是 1。

**位 XOR (`^`) 運算**：

```plain
5 ^ 3 = 0101 ^ 0011 = 0110 (結果是 6)
```

- 當兩個位置的數字不同時，結果是 1，否則結果是 0。

**左移 (`<<`) 運算**：

```plain
5 << 1 = 1010 (結果是 10)
```

- 將所有二進制位左移 1 位，相當於乘以 2。

**右移 (`>>`) 運算**：

```plain
5 >> 1 = 0010 (結果是 2)
```

- 將所有二進制位右移 1 位，相當於除以 2。

### 2. BitMask（Bit Mask）

BitMask 是一個二進制數，用來選擇和操作特定的位。

在我們的情境中，每個字符對應到一個唯一的位，這樣可以用一個整數來表示字符的集合。

#### 字符映射到位

我們可以將 26 個字母（a-z）映射到一個 32 位的整數的不同位上。
假設字符集僅限於小寫字母，那麼：

- 'a' 對應到第 0 位，
- 'b' 對應到第 1 位，
- 'c' 對應到第 2 位，
- 依此類推，直到 'z' 對應到第 25 位。

如果有一個單詞 `"abc"`，那麼我們可以用一個整數來表示這個單詞中包含的字符。
具體地，我們將這些字符所對應的位設置為 1。
這樣，對應的 mask 會是：

```plain
'a' = 第 0 位
'b' = 第 1 位
'c' = 第 2 位
因此， mask 表示為：0000000000000000000000000000111 (十進制是 7)
```

### 3. 如何使用位運算來表示字符集？

假設 `allowed = "abc"`, 我們將 `allowed` 轉換成一個BitMask。

對於每個字符，通過位運算將它映射到一個特定位。

1. 對於每個字符 `char`，計算它相對於 'a' 的位置：

   ```js
   charCode = char.charCodeAt(0) - "a".charCodeAt(0);
   ```

2. 使用左移操作 `1 << charCode`，將對應位設為 1，然後將結果累積到BitMask上：

   ```js
   allowedMask |= 1 << (char.charCodeAt(0) - "a".charCodeAt(0));
   ```

例如，如果 `allowed = "abc"`，則最終的 mask `allowedMask` 會是：

```plain
0000000000000000000000000000111  (即十進制的 7)
```

### 4. 子集（Subset）

當我們處理BitMask時，**子集**的概念可以通過位運算來實現。

如果一個單詞的BitMask是 `wordMask`，那麼只要 `wordMask` 的每一個位都在 `allowedMask` 中出現，我們就可以說這個單詞的字符是 `allowed` 的子集。

#### 子集檢查

假設我們有：

- `allowedMask = 0000000000000000000000000000111` （表示字符 `"abc"`）

- `wordMask = 0000000000000000000000000000101` （表示單詞 `"ac"`）

要檢查 `wordMask` 是否是 `allowedMask` 的子集，可以使用 **位 AND** 運算：

```plain
wordMask & allowedMask === wordMask
```

- 如果這個條件為真，則說明 `wordMask` 中的所有位都在 `allowedMask` 中出現，也就是說這個單詞的字符是 `allowed` 的子集。

#### 例子

- `allowed = "abc"`，所以 `allowedMask = 0000000000000000000000000000111`。
- 一個單詞 `"ac"`，對應的 `wordMask = 0000000000000000000000000000101`。

當你進行位 AND 運算時：

```plain
wordMask & allowedMask = 0000000000000000000000000000101 (這與 wordMask 相同)
```

所以這個單詞是合法的，因為它的所有字符都在 `allowed` 中。

### 5. 小結

通過使用位運算和BitMask，可以高效地表示和比較字符集：

- 每個字符映射到一個唯一的位，並將這些位組合成一個整數。

- 使用位運算來檢查一個單詞的字符是否是某個字符集的子集。

- 位運算的操作速度非常快，並且內存占用很小，因為我們只需要一個整數來表示所有的字符。

這種方法非常適合在字符集有限的情況下進行高效處理，如只處理英文字母的小寫字符。
