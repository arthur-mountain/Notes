# 封包的封裝範例

Before we start, please make sure you have read the

1. [packet overview](./overview.md)

1. [packet format](./format.md)

1. [packet format parse](./format-parse.md)

## 摘要

從底下假設情境中，根據請求從一個設備發送到另一個設備的完整封包結構。

一步步地來解析封包如何通過 OSI 模型逐層封裝。

此範例會展示每層的頭部內容(header)和數據結構，
以展示整個封包從應用層(HTTP 請求)到數據鏈路層(幀)的最終結構。

## **情境設定**

假設:

- 發送端: 私有 IP `192.168.1.10:8080`，公有 IP `203.0.0.1:5925`

- 接收端: 私有 IP `192.168.1.20:3000`，公有 IP `208.0.0.1:8592`

- 傳輸協議: SSL/TLS 包裹的 HTTP POST 請求，內容類型 `application/json`，內容 `{"test":"1234"}`

## **封包逐層封裝結構**

1. **應用層(第七層) - HTTP POST 請求數據**

   - **應用層數據**(HTTP POST 請求):

     ```plaintext
     POST / HTTP/1.1
     Host: 208.0.0.1
     Content-Type: application/json
     Content-Length: 14

     {"test":"1234"}
     ```

   - **加密**: 由於這是通過 SSL/TLS 傳輸的請求，應用層數據會在進入傳輸層前經過 SSL/TLS 加密。

     - **Content Type**: 1 位元組，用來表示記錄的類型(如握手、應用數據)。

     - **Version**: 2 位元組，用來表示 SSL/TLS 版本。

     - **Length**: 2 位元組，表示加密記錄的長度。

     - **加密的應用數據**: 實際加密的 HTTP 請求數據。

2. **傳輸層(第四層) - TCP 段(Segment)**

   - **TCP header**(加密後的數據):

     | 字段        | 長度  | 描述                                          |
     | ----------- | ----- | --------------------------------------------- |
     | 源端口      | 16 位 | 發送方的應用程式端口號，例如: 8080            |
     | 目標端口    | 16 位 | 接收方的應用程式端口號，例如: 3000            |
     | 序列號      | 32 位 | TCP 段的序列號，用於數據重組，例如: 123456789 |
     | 確認號      | 32 位 | 確認收到的數據包序列號，例如: 987654321       |
     | Header 長度 | 4 位  | TCP header 的長度，通常以 4 位元組為單位      |
     | 保留位      | 3 位  | 保留給未來使用                                |
     | 控制位      | 9 位  | 控制位，例如 SYN、ACK、FIN                    |
     | 窗口大小    | 16 位 | 用於流量控制的窗口大小                        |
     | 校驗和      | 16 位 | 對 TCP header 和數據的錯誤檢查                |
     | 緊急指針    | 16 位 | 指示緊急數據的偏移量(如果設置了 URG 位)       |
     | 選項        | 可變  | 例如選擇窗口大小調整、時間戳等                |
     | Padding     | 可變  | 用於使 header 長度為 4 位元組的倍數           |

   - **TCP 段**(包含 header 和加密的 HTTP 數據):

     ```plaintext
     [TCP header]
     [加密的 HTTP 數據 {"test":"1234"}]
     ```

3. **網路層(第三層) - IP 包(Packet)**

   - **IP header**:

     | 字段          | 長度  | 描述                                               |
     | ------------- | ----- | -------------------------------------------------- |
     | 版本          | 4 位  | IP 協議版本(IPv4 為 4)                             |
     | 頭部長度      | 4 位  | Header 長度，以 4 位元組為單位                     |
     | 服務類型(TOS) | 8 位  | 優先級和延遲控制                                   |
     | 總長度        | 16 位 | 包括數據在內的整個 IP 包長度                       |
     | 識別碼        | 16 位 | 分片識別碼，用於重組數據包                         |
     | 標誌          | 3 位  | 分片控制位，如禁止分片、更多分片                   |
     | 分片偏移量    | 13 位 | 分片在數據中的偏移量，例如: 0(表示無分片)          |
     | TTL(生存時間) | 8 位  | 數據包在網路中的生存時間，跳數，例如: 64           |
     | 協議          | 8 位  | 上層協議類型，例如: TCP 為 6                       |
     | Header 校驗和 | 16 位 | 對 IP header 的錯誤檢查                            |
     | 源 IP 地址    | 32 位 | 發送方的 IP 位址，例如: 203.0.0.1(發送端的公有 IP) |
     | 目標 IP 地址  | 32 位 | 接收方的 IP 位址，例如: 208.0.0.1(接收端的公有 IP) |
     | 選項          | 可變  | 一些選項字段，例如安全或路由設置(如果有)           |
     | Padding       | 可變  | 補位，使 header 整數位元組結尾                     |

   - **IP 包**(包含 IP header 和 TCP 段):

     ```plaintext
     [IP header]
     [TCP header + 加密的 HTTP 數據]
     ```

4. **數據鏈路層(第二層) - 以太網幀(Frame)**

   - **以太網 header**:

     | 字段             | 長度             | 描述                                         |
     | ---------------- | ---------------- | -------------------------------------------- |
     | 目標 MAC 地址    | 6 位元組 (48 位) | 接收端的 MAC 位址，例如: `AA:BB:CC:DD:EE:FF` |
     | 源 MAC 地址      | 6 位元組 (48 位) | 發送端的 MAC 位址，例如: `11:22:33:44:55:66` |
     | EtherType        | 2 位元組 (16 位) | 上層協議的類型，例如 `0x0800` 表示 IPv4      |
     | Payload (Data)   | 46-1500 位元組   | 實際承載的數據(IP 包)                        |
     | FCS (幀檢查序列) | 4 位元組         | 錯誤檢查碼，用於數據完整性檢查               |

   - **以太網幀**(包含以太網 header、IP 包和 FCS):

     ```plaintext
     [Ethernet header]
     [IP header + TCP header + 加密的 HTTP 數據]
     [FCS]
     ```

## **最終封包結構(完整封裝)**

將以上各層的數據單位整合起來，最終封包的結構如下：

```plaintext
[Ethernet header]
    [IP header]
        [TCP header]
            [TLS header]
                [加密的 HTTP 數據]
[FCS]
```

## 封裝與解封裝過程

- **發送端**:

  數據經過應用層生成 HTTP 請求後，加密並逐層封裝，到數據鏈路層生成完整的以太網幀並送入網路。

- **接收端**:

  幀到達後，從數據鏈路層逐層解封裝，去掉每層的 header，最終還原應用層的 HTTP 請求數據。

## **總結**

- **Segment、Packet、Frame** 是各層的數據單位，包含 header 和數據。

- **每層的 header 提供必要的協議信息**，便於解封裝和數據路由。

- **SSL/TLS 加密** 在應用層和傳輸層之間完成，因此整個 HTTP 數據在封包過程中被加密。
