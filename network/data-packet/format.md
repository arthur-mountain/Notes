# 封包格式(data packet format)

在開始之前，請確保您已閱讀以下內容：

1. [overview](./overview.md)

2. [Q&A](./QA-001.md)

## Summary

在 OSI 模型中，每一層的封包格式都不同，

因為`每一層都有自己的功能和協議，因此需要不同的頭部(header)`來支持這些功能。

隨著`數據通過各層封裝，每層都會在數據前加上自己的頭部`，最終形成完整的封包，然後從下層往上層解析和傳遞數據。

讓我們來看看各層封包格式的結構：

## 第四層: 傳輸層(Transport Layer)

在傳輸層，常見協議是 **TCP** 和 **UDP**，

它們的頭部信息包含了傳輸數據所需的端口號和其他控制信息。

- **TCP 段(Segment)格式**:

  - **源端口和目標端口**: 標識發送方和接收方的應用程序。

  - **序列號和確認號**:

    TCP 是面向連接的協議，需要跟蹤每個段的序列號和對方的確認號。

  - **標誌位(如 SYN、ACK、FIN)**:

    控制段狀態，如連接建立(SYN)和關閉(FIN)。

  - **窗口大小、校驗和等**: 提供流量控制和錯誤檢查。

- **UDP 數據包(Datagram)格式**:

  - **源端口和目標端口**: 標識發送方和接收方的應用程序。

  - **長度**: 數據包的總長度。

  - **校驗和**: 用於錯誤檢查，但相對簡單。

## 第三層: 網路層(Network Layer)

網路層主要使用 **IP 協議**，包括 IPv4 和 IPv6，

它們的頭部信息主要包含地址和路由信息。

- **IPv4 封包格式**:

  - **版本**: 標識 IP 版本(IPv4)。

  - **報頭長度**: 表示 IP 頭部的長度。

  - **總長度**: 包括頭部和數據的總長度。

  - **識別號、分段信息**: 用於數據包分片和重組。

  - **TTL(生存時間)**: 防止數據包在網路中無限傳播。

  - **協議**: 指示上層協議(如 TCP 或 UDP)。

  - **源地址和目標地址**: IPv4 位址。

- **IPv6 封包格式**:

  - **版本**: 標識 IP 版本(IPv6)。

  - **流標籤**: 標識某個特定流的數據包，便於優化路由。

  - **有效載荷長度**: 不包括頭部的數據長度。

  - **下一個頭部**: 指示上層協議(如 TCP、UDP)。

  - **源地址和目標地址**: IPv6 位址(128 位)。

## 第二層: 數據鏈路層(Data Link Layer)

數據鏈路層使用的封包稱為 **幀(Frame)**，通常使用 **以太網協議**。

它的頭部信息包含物理位址和錯誤檢查信息。

詳情請見 [數據鏈路層的封包(Frame Data Packet)](./frame.md)

## 第一層: 物理層(Physical Layer)

在物理層，數據不再是封包格式，而是轉換為電信號、光信號或無線信號。

這一層並不處理數據內容，而是負責信號的編碼和解碼，以便數據能夠在物理介質中傳輸。

## OSI 模型各層封包格式概覽

當數據通過 OSI 模型各層時，
每一層會添加自己的頭部信息，最終形成完整的封包格式。

這種封裝過程被稱為「封裝」(Encapsulation)，每層的封包格式如下：

| 層級       | 協議             | 封包單位    | 封包格式內容                   |
| ---------- | ---------------- | ----------- | ------------------------------ |
| 應用層     | (如 HTTP、FTP)   | 資料(Data)  | 應用層特定協議數據             |
| 傳輸層     | TCP/UDP          | 段(Segment) | 端口號、序列號、確認號、校驗等 |
| 網路層     | IP(IPv4/IPv6)    | 包(Packet)  | IP 地址、TTL、協議類型         |
| 數據鏈路層 | 以太網(Ethernet) | 幀(Frame)   | MAC 地址、幀檢查序列           |
| 物理層     | 無(Physical)     | 比特(Bits)  | 電信號、光信號、無線信號       |

### 總結

- **OSI 每層都有不同的封包格式**，用於實現該層的功能需求。

- **每層封包都包含一個頭部(header)**，這些頭部逐層封裝，最終在物理層轉換成信號傳輸。

- **封裝與解封裝過程**:

  數據從應用層往下被封裝，每層增加自己的頭部，傳輸時再逐層解封裝，還原數據。

這樣的封裝機制確保了每層的功能獨立，同時使不同層的協議得以協同工作。

[封包是如何根據 header 來被解析得](./format-parse.md)
