# Process substitution

這個語法被稱為**進程替換**（Process Substitution），可以將一個命令的輸出當作文件或輸入來使用。

在 Shell Script 中，進程替換經常用於將命令的輸出直接傳遞給像 `while` 這類的結構，方便後續的處理。

### 進程替換的結構

進程替換有兩種基本的形式：

- `>(...)`：將輸出重定向到進程。

- `<(...)`：將輸入重定向為來自進程的結果。

```bash
js_files=()
while IFS= read -r file; do
  js_files+=("$file")
done < <(find . -type f -maxdepth 1 -name "*.js")
```

範例中，使用的是 `<(...)`，即將 `find` 命令的輸出當作輸入重定向到 `while` 循環中。

這意味著 `while` 循環讀取的內容來自 `find` 命令的結果，而不是來自標準輸入（通常是鍵盤輸入）。

### 具體過程

1. `find /path/to/search -type f` 是一個典型的 `find` 命令，

它會在指定的目錄 `/path/to/search` 中尋找所有文件（因為我們指定了 `-type f` 來過濾文件）。

2. `find` 的輸出通常會列出符合條件的文件路徑，每行一個文件。

3. `<(...)` 將 `find` 命令的輸出重定向成為一個虛擬的文件，這個虛擬文件可以被 `while IFS= read -r` 語句逐行讀取。

   具體來說：

   - `<` 表示將數據（輸入）導入某個命令或結構，這裡是將 `find` 的結果導入 `while`。

   - `(...)` 裡面的 `find` 命令會被執行，結果被作為這個虛擬文件的內容。

   - `< <(find ...)` 實際上是在告訴 Shell：“把這個 `find` 命令的輸出，當作 `while` 循環的輸入來處理。”

4. `while IFS= read -r` 循環會讀取這個由 `find` 命令產生的虛擬文件中的每一行，並將其賦值給變量 `file`。

5. `js_files+=("$file")` 則將每個讀取的 `file`（即每個文件路徑）逐一追加到 `js_files` 數組中。

### 為什麼使用進程替換？

進程替換提供了許多便利，特別是當我們需要將命令的輸出傳遞給一個循環或另一個命令時。它有幾個明顯的優點：

- **避免中間文件**：不需要先將 `find` 的結果寫入臨時文件再讀取，避免了使用磁盤空間或額外的處理步驟。

- **高效的數據流**：進程替換直接在記憶體中運行，數據流是即時的，適合處理大量數據或動態數據。

- **簡化語法**：與管道（`|`）不同，進程替換允許我們直接將一個命令的結果當作輸入傳遞，而不需要額外的數據處理語句。

### 與管道（Pipe）比較

有時我們可能會想到用管道（`|`）來實現類似的效果，例如：

```bash
find /path/to/search -type f | while IFS= read -r file; do
    files+=("$file")
done
```

這樣的方式也可以工作，但有一些潛在問題：

1. **子 Shell 問題**：在某些情況下，使用管道會啟動一個子 Shell 來執行 `while` 循環，
   這樣變數（如 `files`）的值可能無法被正確地保留到父 Shell 中。

2. **進程替換更直觀**：進程替換是一種更乾淨的方式，允許我們將命令的輸出直接作為輸入文件，而不需要考慮子 Shell 等副作用。

### 小結

`< <(...)` 使用了進程替換，它將 `find` 命令的輸出重定向成為一個虛擬文件，

從而可以被 `while` 循環逐行讀取並處理。

這種方法既簡潔又高效，避免了臨時文件和子 Shell 問題，適合 Shell Script 中的各類場景。
