# SSL/TLS And TCP/UDP Socket Descriptor

## **TCP 和 UDP 的 Socket Descriptor 差異**?

當建立網路通信時，**TCP 和 UDP 的 socket descriptor 有以下主要差異**：

- **TCP Socket Descriptor**:

  - **狀態管理**: TCP 是連接導向的協定，需要維護連接的狀態，包括 `ESTABLISHED`、`CLOSE_WAIT` 等，並管理三次握手和四次揮手的過程。

  - **數據可靠性**: 包含數據重傳、流量控制、擁塞控制等機制，確保數據可靠傳輸。

  - **雙工通信**: 支持雙向通信，同一個 TCP socket descriptor 用於接收和發送數據。

- **UDP Socket Descriptor**:

  - **無狀態**: 無需維護連接狀態，每次通信即一個獨立的數據包傳輸。

  - **簡單數據傳輸**: 不提供重傳和流量控制等功能，傳輸效率高，但可能丟包或順序錯亂。

  - **面向消息**: 每次操作對應一個完整的數據報，與 TCP 的數據流不同。

## 那建立 socket descriptor，是怎麼處理 SSL 的?

當我們建立一個套接字(socket) 並想要啟用SSL/TLS加密連線時，

實際上是在基本的socket(通常會是 TCP Socket Descriptor)上建立了一個加密的「SSL套接字」。

這需要通過 SSL/TLS 協定來處理數據加密和驗證的流程。

以下是這個過程的主要步驟以及Kernel和應用程式之間的協作方式:

### 1. 建立基本的 TCP 套接字

SSL/TLS 加密通常基於TCP協定，因此第一步是創建一個普通的TCP套接字，

並通過標準的`socket()`系統呼叫來實現。在這一步中，這個套接字還未進行加密，數據傳輸都是純文本的。

### 2. 升級 TCP 套接字至 SSL 套接字

要啟用 SSL/TLS，需要通過應用層的SSL庫來將普通TCP套接字「升級」成SSL套接字。

在Linux環境中，這通常使用 OpenSSL 或其他類似的SSL library來實現。這些SSL庫負責建立安全的加密通道，具體步驟如下:

- **初始化SSL庫**: 首先，應用程式需要初始化SSL庫(例如OpenSSL的`SSL_library_init()`函數) 。

- **創建SSL上下文**: 應用程式會創建一個SSL上下文(SSL Context) ，這是SSL配置的主要結構，用來保存SSL協定版本、加密套件、證書等配置信息。

- **綁定套接字**: 將已經建立的TCP套接字綁定到SSL上下文上，這樣應用程式就可以對套接字進行加密操作了。

### 3. SSL 握手(SSL Handshake)

完成初始化後，應用程式會通過SSL套接字啟動「握手」(Handshake) 過程。握手是SSL/TLS連線中非常重要的一步，包含以下主要階段:

- **協定協商**: 客戶端和伺服器會協商SSL/TLS版本以及加密套件，選擇雙方都支持的加密方法。

- **證書交換和驗證**: 伺服器將其SSL證書發送給客戶端，客戶端驗證證書的有效性(例如通過驗證CA證書) 。

- **密鑰生成與交換**: 客戶端和伺服器通過非對稱加密方法交換對稱加密密鑰，這個密鑰將用於後續的數據加密。

- **握手完成**: 一旦雙方確認加密協議和密鑰，握手結束，並進入加密通訊階段。

在這個過程中，SSL庫會使用Kernel提供的基本套接字進行通訊，但它會對數據進行加密和解密，
這些操作都是在應用層完成的，Kernel並不直接參與SSL加密。

### 4. 加密數據的傳輸

握手完成後，應用程式可以通過SSL套接字傳輸加密數據。以下是加密傳輸的流程:

- **應用層數據加密**: 當應用程式需要傳送資料時，SSL庫會先加密資料，然後通過TCP套接字發送出去。

- **加密資料傳輸**: 加密數據經由TCP套接字發送到Kernel，由Kernel負責將封包通過網卡傳輸出去。

- **接收端解密數據**: 接收方的SSL庫會將數據從TCP套接字中讀取，並在應用層進行解密，然後再提供給應用程式使用。

### 5. SSL 套接字的關閉

當連線結束時，應用程式會通知SSL庫進行安全關閉(SSL Shutdown) 。這個過程會包括兩部分:

- **SSL/TLS結束握手**: 通知對方連線即將關閉，雙方完成結束的數據交換。

- **TCP套接字的關閉**: SSL關閉後，應用程式會按照標準方式關閉基礎的TCP套接字。

## Kernel 與 SSL 的關係

需要注意的是，Kernel只負責處理TCP層的數據傳輸，而SSL/TLS的加解密以及協商工作完全在應用層進行。

Kernel只是將加密後的數據當作普通的TCP數據來傳輸，因此不需要特別處理SSL協議。

## SSL/TLS 與 TCP 套接字的關係

SSL本身並不「啟動自己的套接字描述符」，而是**在應用層包裹(wraps)**原始的TCP套接字描述符，
並通過該描述符進行加密和解密的數據交換。以下是更詳細的解釋:

### 1. SSL/TLS 套接字的包裹方式

當我們在應用程式中使用SSL/TLS時，
我們會先建立一個基本的TCP套接字(通常是基於`socket()`函數建立的TCP描述符) ，
然後將這個TCP套接字傳遞給SSL庫(如OpenSSL) ，並**包裹成一個SSL/TLS「虛擬」套接字**。

這個虛擬SSL套接字仍然依賴於底層的TCP套接字，並不會啟動一個額外的套接字描述符。

- **TCP 套接字描述符**:
  TCP套接字描述符是唯一的，是Kernel創建和管理的，負責底層的數據傳輸。

- **SSL/TLS 虛擬套接字**:
  SSL庫會建立一個SSL結構(如OpenSSL的`SSL`物件) ，它不是一個額外的描述符，而是一層軟體抽象。
  這個SSL結構包裹了原始的TCP描述符，並負責數據的加解密和SSL協定的處理。

### 2. 數據傳輸過程

當進行加密數據傳輸時，整個數據流程如下:

- **發送數據**:

  1. 應用程式通過SSL虛擬套接字發送數據(如調用`SSL_write()`) 。

  2. SSL庫會先在應用層對數據進行加密(基於握手期間協商的加密密鑰和加密套件) 。

  3. 加密後的數據會通過底層的TCP套接字描述符(原始的socket) 發送出去。

- **接收數據**:

  1. 目標端接收數據時，數據先到達Kernel的TCP層，並放入接收方的TCP套接字描述符緩衝區。

  2. 接收方的SSL庫通過TCP套接字讀取這些加密數據(如使用`SSL_read()`) 。

  3. SSL庫在應用層解密數據，並將解密後的數據返回給應用程式。

## 因此

- **單一的TCP套接字描述符**: 底層只有一個TCP套接字描述符，用來傳輸數據。SSL/TLS只是包裹了這個套接字，並不創建額外的套接字描述符。

- **SSL/TLS在應用層進行加解密**: SSL庫將數據加密後，經由同一個TCP套接字傳輸，對方的SSL庫通過同一個TCP套接字接收數據並解密。

- **應用層與Kernel層的配合**: SSL的加解密和協定處理均在應用層進行，Kernel層不會直接接觸到解密或加密數據，只會看到經過加密的傳輸數據。

換句話說，`**整個加解密流程是在原有的TCP套接字描述符上包裹SSL/TLS邏輯**`，沒有增加新的套接字描述符。

## SSL/TLS 的數據傳輸流程

1. **建立TCP套接字描述符**:
   應用程式首先建立一個TCP套接字描述符，這個描述符是作業系統 kernel 管理，負責底層的數據傳輸。

2. **將TCP套接字描述符交給SSL層**:
   應用程式將這個TCP套接字交給SSL庫(例如OpenSSL) 進行包裹(wraps)。
   SSL library 透過這個TCP套接字來傳輸加密和解密的數據，但並不創建額外的套接字描述符。

3. **傳輸數據的過程**:

   - **發送數據**:

     - 應用程式將數據傳給SSL層(例如透過`SSL_write()`) 。

     - SSL層在應用層加密數據。

     - 加密後的數據透過TCP套接字描述符發送出去。

   - **接收數據**:

     - 目標端的TCP套接字描述符接收到加密的數據。

     - SSL層從TCP套接字描述符中讀取數據(例如透過`SSL_read()`) ，並在應用層進行解密。

     - 解密後的數據交給應用程式使用。

## 流程圖總結

1. **application**(發送端的應用程式): 應用程式希望發送數據，因此將數據傳送給SSL層。

2. **ssl**(發送端的SSL層): SSL層在應用層對數據進行加密，並準備好要透過TCP套接字發送的加密數據。

3. **tcp socket descriptor**(發送端的TCP套接字描述符): 加密後的數據透過這個TCP套接字描述符由Kernel傳輸出去，經過網路送達對方。

4. **對方的 tcp socket descriptor**(接收端的TCP套接字描述符): 對方的TCP套接字描述符接收到數據(數據在網路中是加密的) 。

5. **對方的 ssl**(接收端的SSL層): SSL層從TCP套接字讀取加密數據，並在應用層進行解密。

6. **對方的 application**(接收端的應用程式): 解密後的數據傳遞給對方的應用程式，這樣接收方就能獲取到原始的明文數據。

整個數據傳輸過程，示意圖如下:

```
application -> SSL/TLS -> tcp socket descriptor -> [網路傳輸] -> 對方的 tcp socket descriptor -> 對方的 SSL/TLS -> 對方的 application
```

## 總結

- 整個數據流程中只會有一個TCP套接字描述符。

- **SSL加密在應用層進行**: Kernel提供的基本套接字用於數據傳輸，但SSL/TLS的加解密和握手完全在應用層(由SSL庫) 處理。

- TCP套接字描述符負責傳輸加密後的數據，對方接收後解密，返回給應用程式。

- **Kernel 的角色**: Kernel只負責傳輸數據，並不參與SSL/TLS協定的細節處理。
